<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="xp.css">
    <title>Sploder</title>
</head>
<script>
    // Wait for DOM to be fully loaded before initializing
    document.addEventListener('DOMContentLoaded', initializeApp);

    async function initializeApp() {
        // Check get parameter to get URL
        const queryString = window.location.search;
        const urlParams = new URLSearchParams(queryString);
        const url = urlParams.get('url');

        // If the URL is not provided, redirect to the update page
        if (url == null) {
            try {
                const updateUrl = await window.electronAPI.getUrl('update');
                window.location.href = updateUrl;
            } catch (error) {
                console.error('Error getting update URL:', error);
                // Fallback to hardcoded URL in case of error
                window.location.href = "https://sploder.com/update";
            }
        }
        
        // Store URL in a global variable for other functions to access
        window.initialURL = url;
        
        var page;
        var prevpage;
        var pagestat;
                
        // Set up document content
        document.getElementById("content-frame").setAttribute('src', url);
        
        // Initialize the button state
        checkmax();
        
        // Set up additional window state listeners
        setTimeout(() => {
            window.addEventListener('resize', () => {
                setTimeout(checkmax, 50);
            });
            
            // Additional event listener for the title bar
            const titleBar = document.querySelector('.title-bar');
            if (titleBar) {
                titleBar.addEventListener('mouseup', () => setTimeout(checkmax, 50));
                titleBar.addEventListener('dblclick', () => setTimeout(checkmax, 50));
            }
            
            // Listen for window state changes directly from the main process
            if (window.electronAPI && window.electronAPI.onWindowStateChange) {
                window.electronAPI.onWindowStateChange((isMaximized) => {
                    const maxButton = document.getElementById('max-btn');
                    if (maxButton) {
                        maxButton.setAttribute('aria-label', isMaximized ? 'Restore' : 'Maximize');
                    }
                });
            }
        }, 100);
        
        // Start the interval functions
        setInterval(discordrpc, 15000);
    }
    
    // Window control functions using IPC
    async function toggleMaximize() {
        try {
            const maxButton = document.getElementById('max-btn');
            if (!maxButton) return; // Safety check
            
            // Call the maximize function which returns true if window is now maximized
            const isMaximized = await window.electronAPI.maximizeWindow();
            
            // Update button appearance immediately based on the returned state
            if (isMaximized) {
                maxButton.setAttribute('aria-label', 'Restore');
            } else {
                maxButton.setAttribute('aria-label', 'Maximize');
            }
        } catch (error) {
            console.error('Error in toggleMaximize:', error);
        }
    }
    
    async function checkmax() {
        try {
            const maxButton = document.getElementById('max-btn');
            if (!maxButton) return; // Safety check
            
            // Get the current window state
            const isMaximized = await window.electronAPI.isWindowMaximized();
            
            // Update the button's appearance based on the window state
            if (isMaximized) {
                if (maxButton.getAttribute('aria-label') !== 'Restore') {
                    maxButton.setAttribute('aria-label', 'Restore');
                }
            } else {
                if (maxButton.getAttribute('aria-label') !== 'Maximize') {
                    maxButton.setAttribute('aria-label', 'Maximize');
                }
            }
        } catch (error) {
            console.error('Error in checkmax:', error);
        }
    }
    
    // Run checkmax at a regular interval to keep the button state in sync
    setInterval(checkmax, 100);
    
    // Add event listeners for window state changes
    window.addEventListener('resize', checkmax);
    document.addEventListener('mouseup', checkmax);
    
    // Keep updating the Discord RPC message
    var rpcinfo;
    function discordrpc() {
      try {
        rpcinfo = document.getElementById("content-frame").contentWindow.window.rpcinfo;
      } catch (error) {
        console.error('Error in discordrpc:', error);
      }
    }
    setInterval(discordrpc, 15000);
// Custom built code to check if user is online.
// I have no idea how or why this works.
  async function online() {
    if(document.getElementById("content-frame").contentWindow.location.href != "chrome-error://chromewebdata/"){
    page = document.getElementById("content-frame").contentWindow.location.href;
    } else if(page == undefined) {
      page = window.initialURL || ''; // Use the stored global URL
    }
    if(page.includes("offline.html")){
      page = "test";
    } else {

    
    const frame = document.getElementById('content-frame');
    try {
      var pingUrl = await window.electronAPI.getUrl('ping');
      var xhttp = new XMLHttpRequest();
      xhttp.onreadystatechange = function() {
      
        if (this.readyState == 4 && this.status != 200 && frame.getAttribute('src') != "offline.html?retry="+page) {
          if(page != "test") {
          prevpage = page;
          }
          pagestat = "offline";
          page = "offline.html";
      frame.setAttribute('src', 'offline.html?retry='+page);
      
        } else if(document.getElementById("content-frame").contentWindow.location.href != "chrome-error://chromewebdata/") {
          page = document.getElementById("content-frame").contentWindow.location.href;
        } else {
          if((page == "test") && (pagestat == "offline")){
            frame.setAttribute('src', prevpage);
          }
          //pagestat = "online";
        }
        
    };
    xhttp.open("GET", pingUrl, true);
    xhttp.send();
    } catch (error) {
      console.error('Error getting ping URL:', error);
    }
  }
  }
  // Add window focus and blur listeners to check window state
  window.addEventListener('focus', function() {
    setTimeout(checkmax, 50);
  });
  
  window.addEventListener('blur', function() {
    setTimeout(checkmax, 50);
  });
  
  // Prevent scrolling using JavaScript
  window.addEventListener('scroll', () => {
    window.scrollTo(0, 0); // Keep the window locked at the top
  });

  // Disable scroll-related JavaScript methods
  window.onscroll = () => window.scrollTo(0, 0);

  document.addEventListener('wheel', (event) => {
    event.preventDefault(); // Disable mouse wheel scrolling
  }, { passive: false });

  document.addEventListener('keydown', (event) => {
    if (["ArrowUp", "ArrowDown", "PageUp", "PageDown", "Home", "End"].includes(event.key)) {
      event.preventDefault(); // Disable keyboard scrolling
    }
  });




</script>
<style>
    body, html {
        background: linear-gradient(180deg,#0050ee 40%,#06f 88%,#06f 93%,#005bff 95%,#003dd7 96%,#003dd7);
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
        overflow: hidden;
    }
    iframe {
        width: calc(100% - 6px);
        height: calc(100% + 22px);
        border: none;
    }
    .titlebar-movable {
        width: 100%;
        height: 100%;
        display: flex;
        user-select: none;
        -webkit-user-select: none;
        -webkit-app-region: drag;
    }
    .title-bar-text {
        user-select: none;
        -webkit-user-select: none;
        -webkit-app-region: drag;
        font-family: Tahoma, 'Microsoft Sans Serif', Arial, sans-serif;
        font-size: 12px;
        font-weight: bold;
        color: #fff;
        text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.7);
    }
    .window {
      background-color: #32103C;
    }
    .title-bar {
      border-radius: 0px;
    }
    .title-bar-icon {
      width: 16px;
      height: 16px;
      margin-left: 3px;
      margin-right: 3px;
      user-select: none;
      -webkit-user-select: none;
      -webkit-app-region: drag;
    }
    .candrag {
      user-select: none;
      -webkit-user-select: none;
      -webkit-app-region: drag;
    }
</style>
<body>
  
    <div class="window" style="width: 100%; height: calc(100% - 3px)">
        <div class="title-bar" id="titlebar">
          <img class="title-bar-icon" src="images/icon.png">
          <div class="title-bar-text">Sploder</div>
          <div class="titlebar-movable" onmouseup="setTimeout(checkmax, 50)" onmousedown="setTimeout(checkmax, 500)"></div>
          <div class="title-bar-controls">
            <button id="min-btn" onclick="window.electronAPI.minimizeWindow()" aria-label="Minimize"></button>
            <button id="max-btn" onclick="toggleMaximize()" aria-label="Maximize"></button>
            <button id="close-btn" onclick="window.electronAPI.closeWindow()" aria-label="Close"></button>
          </div>
        </div>
        <div class="window-body"
          style="width: 100%; height: calc(100% - 50px); margin-left: 3px; margin-top:0px; padding-bottom: -50px;">
          <iframe id="content-frame" onload="online();" src="">
            </iframe>
          <!-- The src will be set by initializeApp function -->
           
        </div>
      </div>
      
</body>
</html>